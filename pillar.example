docker:
  # repository setting, will differ for diffirent os families, see osfamilymap for example
  repo: {}
  # docker server setting
  server:
    # install or not docker server (daemon)
    install: true
    # installation method for docker server
    # repo, package - install form official repo with system packages (deb, rpm)
    # binary - install via official pre compiled static binaries, *not implemented yet*
    use_upstream: repo
    # parameters for package installation method, official Docker repository will be used
    package:
      pkgs:
        - docker-ce
        - docker-ce-cli
        - containerd.io
      hold: false
      update_holds: true
    # install extra dependencies required for docker daemon to operate properly
    # they will be installed *before* main package(s)
    extra:
      # list of packages to install
      pkgs:
        # python-docker package is mandatory (where available),
        # required for salt to communicate with docker daemon
        - python3-docker
        - iptables
        - procps
        - pigz
        - xz-utils
    # install packages via pip when required system packages are not available or too old
    # i.e. python-docker package is not available or too old on CentOS, RedHat
    # https://github.com/saltstack/salt/issues/58920#issuecomment-726328964
    # by default pip packages are used on RedHat family systems only
    pip:
      # system package with pip utility
      package: python3-pip
      # list of packages to install with pip
      pkgs:
        - docker
    # parameters for binary installation method, official pre compiled static binaries will be used
    # not implemented yet
    binary: {}
    # configuration of docker daemon
    config:
      file: /etc/docker/daemon.json
      data:
        # by default try to use sockets provided by systemd
        # for more info see https://github.com/moby/moby/issues/25471
        hosts:
          - fd://
          # if you want to expose TLS protected TCP socket it must be added to this list,
          # and daemon must be restarted, reload is not enough to activate new socket!
          # - tcp://0.0.0.0:2376
        # TLS related options, more info in official docs
        # https://docs.docker.com/engine/security/protect-access/#use-tls-https-to-protect-the-docker-daemon-socket
        # NOTE:
        # - there is no default values for TLS parameters
        # - you MUST provide existing certificate and key via
        #   docker:server:tls:key:source, docker:server:tls:cert:source or via
        #   docker:server:tls:key:content, docker:server:tls:cert:content
        #   alternatively selfsigned certificate can be created by providing
        #   parameters in docker:server:tls:key:params, docker:server:tls:cert:params
        # - if you provide path for tlskey, tlscert but files are not in place
        #   docker daemon will fail to start
        #
        # enable TLS protected TCP socket
        tls: false
        tlskey: /etc/docker/tls/server-key.pem
        tlscert: /etc/docker/tls/server-cert.pem
        # enable client certificate verification
        tlsverify: false
        # client certificate will be validated against this CA certificate
        tlscacert: /etc/docker/tls/ca.pem
    # docker daemon service settings
    service:
      name: docker
      status: running
      enable: true
      # NOTE if configuration related to docker daemon sockets is changed
      # full restart is required - 'reload: false' must be used
      reload: true
      daemon_args:
        - '--containerd=/run/containerd/containerd.sock'
    tls:
      # packages required to issue self signed certificates
      pkgs:
        - openssl
        - python3-m2crypto
      key:
        # create symlink with name docker:server:config:data:tlskey
        # 'source' will be used as the symlink target, it MUST be absolute path in this case
        symlink: false
        # source file for private key (tlskey)
        # if source:
        # - starts with 'salt://' it will be used 'as is'
        #   this way arbitrary file from salt file server can be used
        # - is an absolute path i.e. '/etc/pki/example.tld.key'
        #   local (to minion) file will be used
        # otherwise formula will search for file in `formula_root/files/tls/%key_source%`
        source: ''
        # you can provide private key and certificate data directly in pillars
        # data from pillars does have higher priority, if values for:
        # key:source, key:content both are present, data from key:content will be used
        content: |
            -----BEGIN RSA PRIVATE KEY-----
            [Private key here]
            -----END RSA PRIVATE KEY-----
        # creation of self signed private key does have lowest priority
        # key:source, key:content keys must be absent
        # then key:params value will have effect and new private key will be created
        # required minimum is a 'bits' parameter, usually 2048 bits are enough
        params:
          bits: 2048
        # show changes (diff) when updating private key from 'source' or form 'content'
        # when new key will be generated with x509.private_key_managed changes will always be displayed
        show_changes: false
      cert:
        # create symlink with name docker:server:config:data:tlscert
        # 'source' will be used as the symlink target, it MUST be absolute path in this case
        symlink: false
        # source file for certificate (tlscert), same rules as for key:source
        source: ''
        content: |
            -----BEGIN CERTIFICATE-----
            [Certificate here]
            -----END CERTIFICATE-----
        # parameters for self signed certificate, does have lowest priority
        # cert:source, cert:content keys must be absent
        # then cert:params value will have effect and self signed certificate will be issued
        # almost any valid parameter of Salt x509.certificate_managed state can be used here
        params:
          days_valid: 3650
          CN: example.tld
          # use minion id as a Common Name
          # CN: {{ grains.id }}
          subjectAltName: "DNS:example.tld,DNS:www.example.tld,IP:127.0.0.1"
        # show changes (diff) when updating certificate from 'source' or form 'content'
        # when new cert will be issued with x509.certificate_managed changes will always be displayed
        show_changes: false
      # you need to provide 'tlscacert' if you want to use 'tlsverify' (verifly client certificate)
      cacert:
        # create symlink with name docker:server:config:data:tlscacert
        # 'source' will be used as the symlink target, it MUST be absolute path in this case
        symlink: false
        # source file for tlscacert, same rules as for key:source
        source: ''
        content: |
            -----BEGIN CERTIFICATE-----
            [CA Certificate here]
            -----END CERTIFICATE-----
        # show changes (diff) when updating CA certificate from 'source' or form 'content'
        show_changes: false
  # docker-compose related data
  compose:
    # install or not docker-compose
    install: true
    # docker-compose installation methon
    # only binary implemented for now, due lack of alternatives
    install_method: binary
    version: 1.29.0
    # symlink this to desired docker-compose version in `version_dir` directory
    bin: /usr/local/bin/docker-compose
    # different versions of docker-compose will be saved in this directory
    # as %version_dir%/docker-compose-%version%
    version_dir: /usr/local/lib/docker-compose
    # shell completion for docker compose
    # https://docs.docker.com/compose/completion/
    shell_completion:
      bash:
        install: true
        # system bash-completion package
        package: bash-completion
        # source with bash-completion script for docker-compose, will be used 'as is'
        source: ''
        # default source is generated from multiple variables: %download_remote%/%version%/%remote_path%
        download_remote: https://raw.githubusercontent.com/docker/compose/
        remote_path: contrib/completion/bash/docker-compose
        # where to install bash-completion script
        dir: /etc/bash_completion.d
    # docker-compose binary installation method parameters
    binary:
      # source for docker-compose itself
      # absolute url for file.managed 'source' parameter, will be used 'as is'
      source: ''
      # source for file with checksum for docker-compose binary
      # absolute url for file.managed 'source_hash' parameter, will be used 'as is'
      source_hash: ''
      # default source is generated from multiple variables and grains:
      # %download_remote%/%version%/docker-compose-%grains.kernel%-%grains.cpuarch%
      download_remote: https://github.com/docker/compose/releases/download/
      source_hash_remote: https://github.com/docker/compose/releases/download/
  # manage docker volumes
  volumes:
    # volume id, will be used as volume name if 'name' not specified explicitly
    # minimum required declaration - only id
    portainer_data: {}
    bar:
      # ensure mode (optional) - 'present' or 'absent', volume will be created or removed respectively
      # default is 'present'
      ensure: present
      # ensure: absent
    baz:
      ensure: present
      # this volume will have 'fizbuz' name
      name: fizbuz
      # any valid parameters for `docker_volume.present` state can be used
      driver: local
      driver_opts: {}
    # this volume will be removed
    zap:
      ensure: absent
  # manage docker networks
  networks:
    # network id, will be used as network name if 'name' not specified explicitly
    proxy-net:
      # ensure mode (optional) - 'present' or 'absent', network will be created or removed respectively
      # default is 'present'
      ensure: present
      # ensure: absent
    mynet:
      ensure: present
      # any valid parameters for `docker_network.present` state can be used
      driver: macvlan
      driver_opts:
        - macvlan_mode: bridge
        - parent: eth0
      labels:
        - foo
        - bar=baz
        - hello: world
  # manage docker containers
  containers:
    traefik:
      # optional, if 'ensure' key is not provided 'ensure: running' is assumed
      ensure: running
      # ensure: stopped
      # ensure: absent
      name: traefik-proxy
      image: traefik:latest
      restart_policy: always
      binds:
        - /var/run/docker.sock:/var/run/docker.sock:ro
      command:
        - '--api.insecure=true'
        - '--providers.docker.watch=true'
      publish:
        - 8080:8080
    portainer:
      ensure: running
      image: "portainer/portainer-ce:linux-amd64-2.1.1"
      restart: always
      command:
        # set admin password (p@ssw0rd in this example)
        - '--admin-password="$2y$05$ROLmgJ2bwAFgWLkOCouhTe/nJ/bEDgs6i1Cd856hbAMP2W8M2ra/O"'
      binds:
        - /var/run/docker.sock:/var/run/docker.sock
        # portainer_data volume is defined under 'volumes' key
        - portainer_data:/data
      publish:
        - 9000:9000
        - 8000:8000
